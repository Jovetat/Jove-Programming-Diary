# Vue

## Vue2 vs Vue3
- Vue2使用Object.defineProperty递归代理，Vue3使用Proxy
- Options API → Composition API
- 更好的TypeScript支持
- ESM按需引入 & Tree Shaking
- diff算法从递归改为队列+静态标记

## scoped原理
- 为每个DOM元素添加[data-v-xxx]属性（相同组件不同DOM这个属性值相同）
- CSS选择器添加属性选择器后缀实现样式隔离

## diff算法
- 只比较同级，不跨级比较（时间复杂度是n，严格对比时间复杂度是n3）
- tag不同直接删除重建
- 子节点通过key区分
- Vue2：双端比较
- Vue3：最长递增子序列

## 循环中必须使用key的原因
- diff算法根据key判断元素是否需要删除
- 匹配到key只移动元素，性能较好
- 未匹配key则删除重建，性能较差

## 双向绑定原理

- 数据劫持（Object.defineProperty或Proxy）
- 发布订阅模式（实现子更新父数据）

# React

## 常用Hook

- useState、useEffect、useRef、useContext

## Hook

让函数组件能用上状态和生命周期

## Hook 否在循环中使用
- 不能在循环、条件判断或嵌套函数中调用
- Hook需要每次渲染都以相同的顺序执行，这样才能识别每个Hook对应的状态
- Hook调用顺序不一致，React没法正确追踪状态
- 官方明确规定Hook只能在组件的顶层作用域或者自定义Hook中调用

## Fiber架构
- 解决递归渲染DOM树的性能问题
- 将DOM树改为链表树
- 将渲染任务拆分成小单元，可中断
- 优先执行交互任务

## 渲染原理
- 虚拟DOM ➕ 调和（处理虚拟DOM）
- JSX → 虚拟DOM → 真实DOM
- 状态变化时生成新虚拟DOM，对比差异后同步到真实DOM

# 前端框架

## Vue vs React

**相同点**

- 都是前端框架，用于快速搭建页面
- 都使用虚拟DOM
- 都支持组件化开发

**差异点**

- **数据响应式**：Vue通过代理监听响应式数据变化，React需要setState触发重新渲染
- **Diff算法**：Vue跟踪每个组件依赖精准更新；React从根节点递归比较

  > React：仅右移
  > Vue2：双端比较
  > Vue3：最长递增子序列，减少中间的对比次数
- **语法**：Vue使用模板语法，React使用JSX
- **数据流**：Vue是双向数据流，React是单向数据流
- **适用场景**：Vue适合快捷开发，React更灵活适合复杂项目

## Next.js

- 全栈框架：基于 React 的完整全栈开发框架
- 服务端渲染：支持 SSR，提升首屏加载速度和 SEO
- 静态站点生成：支持 SSG，构建时预渲染页面
- 混合渲染：可根据页面需求选择 SSR、SSG 或 CSR
- 文件系统路由：基于文件结构自动生成路由
- API 路由：内置 API 支持，无需额外配置服务器
- Server Component：Next.js在推，组件在服务器端渲染，直接将渲染好的html发送给浏览器，省去了大量JS代码打包，减少浏览器内存占用和计算负担，加快首屏加载速度

# 前端工程化

## 工程化解决了什么问题

当一个项目很大的时候，就可能会出现

- 全局污染（函数名、变量名冲突）
- 依赖混乱（JS文件间互相调用引起的依赖混乱）

## 工程化内容

- 模块规范
     CommonJS`同步，适合Node`、ESM（ES module）`异步，适合前端开发`
     规定代码怎么拆分成模块

- 工程化工具
     webpack、Vite
     解决模块打包、代码转译、热更新、开发服务器等一些列问题

- 前端框架
     Vue、React
     快速搭建用户界面，不用自己手写复杂的DOM操作

## 前端错误捕获

- try-catch 同步错误捕获
  用于捕获同步代码中的错误，无法捕获异步错误和语法错误

- window.onerror 全局错误捕获
  全局错误监听，可以捕获运行时错误，但无法捕获资源加载错误

- window.addEventListener error 资源加载错误

  专门捕获图片、脚本、样式表等资源加载失败的情况

- unhandledrejection Promise错误捕获
  捕获未被处理的Promise拒绝（rejection）错误

- Vue错误处理 app.config.errorHandler
  Vue提供的全局错误处理钩子，捕获组件渲染和观察期间未捕获的错误

- React错误边界
  React组件级的错误捕获机制，用于捕获子组件树中的JavaScript错误

- 网络请求错误捕获
  针对fetch、XMLHttpRequest等网络请求的错误处理

- 控制台错误重写
  重写console.error等方法，监控和控制台输出相关的错误

- 跨域脚本错误处理 window.onerror中message是 'Script error.'
  处理由于跨域策略导致的脚本错误信息受限问题

- 性能监控错误
  通过Performance API监控长时间任务等性能相关问题

## Vite vs Webpack

**Webpack**

- 打包所有模块再启动开发服务（冷启动较慢）
- 生态更完善，插件丰富
- 配置相对复杂

**Vite**

- ESM按需加载，不用打包，开发服务器启动快
- 基于Rollup打包，体积更小
- 更轻量，开发体验更好
- 热更新更快（文件指纹）

## CommonJS vs ES Module

**CommonJS**

- 运行时加载
- 导出的是值的拷贝
- 同步加载，适合Node.js

**ES Module**

- 编译时加载，支持静态分析（不运行代码就知道模块之间的依赖关系）
- 导出的是值的引用
- 异步加载，适合浏览器
- 支持Tree Shaking

## Hash模式 VS Histroy模式

**Hash模式**

- URL格式：`http://example.com/#/page`
- 原理：监听URL中#后面的哈希值变化
- 刷新影响：不会触发页面刷新
- 部署要求：无需服务器特殊配置
- SEO支持：较差，搜索引擎不识别#后内容

**History模式**

- URL格式：`http://example.com/page`
- 原理：使用HTML5 History API（pushState, replaceState）
- 刷新影响：会向服务器发送请求
- 兼容性：需要IE10+或现代浏览器
- 部署要求：需要服务器配置，所有路由指向index.html
- SEO支持：良好，URL更友好易被搜索引擎收录

## webview与h5的通讯

- PostMessage：支持跨域，双方都需要发送消息和监听
- URL Scheme拦截：H5跳转自定义URL，webview拦截并解析URL参数
- JSbridge：通过注入原生对象到H5的window上，H5调用该对象方法，原生监听并处理，再回调结果给H5
- WebSocket：建立长链接，WebView和H5通过消息推送实时通信
- 本地存储共享：通过LocalStorage、sessionStorage共享数据，各自写入各自读取
- Cookie共享：可以同步登陆状态

## 微前端

**目的**：

- 解决巨石应用（维护性、打包、管理、降低开发和维护成本）
- 解决遗留系统迁移

**原理**：主应用加载和管理子应用

vue和react都是将所有内容最终挂在在一个dom上，而微前端就是主应用统一管理挂载和卸载，并处理一下通讯和样式隔离

**优化**：

- 样式隔离：Shadow DOM
- 通信：消息订阅发布、EventBus（总之都是在创建子应用的时候传入了函数）
- 模块公用和依赖管理
- 子应用懒加载和预加载

**缺点**：

- 应用间通信复杂
- 全局状态管理和样式隔离需要额外处理
- 首次加载性能开销

## 前端整合方案

**iframe**

- 无法共享登录态
- 通信复杂
- 隔离性最好

**微前端**

- 适合大型项目多子应用
- 完善的生态和解决方案

**Web Components**

- 原生JS组件化方案
- 保持样式和逻辑一致性

## webcomponents

原生JS组件化

## iframe通信

- postmessage
- localStroage和sessionStorage
- 通过操作iframe页面的window对象进行通信（需要同源）

## iframe缺点

- 无法和主项目共享登录态
- 无法像一个项目一样通讯

## 分包

**概念**：将应用代码拆分成多个包，按需加载
**作用**：减少首屏加载时间，优化缓存策略，提高构建效率
**核心价值**：提升用户体验，控制包大小，实现渐进式加载
**分包原理**：

- 依赖分析：构建工具分析模块间依赖关系
- 代码分割：通过分割点将代码提取到独立chunk
- 动态加载：运行时按需加载分包代码
- 资源管理：独立缓存和版本控制

### 不同框架分包实现

**Webpack**
- 动态导入：`import()`语法自动分包
- 配置分割：splitChunks配置vendor包
- 魔法注释：webpackChunkName指定包名
- 预加载：webpackPrefetch预加载非关键包

**Vite**

- ESM原生：基于ES模块的按需加载
- Rollup配置：manualChunks手动分块
- 自动优化：依赖分析自动提取公共模块

**小程序**

- 配置驱动：app.json中配置subpackages
- 独立分包：independent字段标记独立运行
- 预加载规则：preloadRule配置预加载策略
- 大小限制：主包2M，总分包20M

### 独立分包

- 核心特点：不依赖主包独立运行
- 启动优势：直接加载分包，跳过主包
- 限制：无法共享主包样式和组件
- 适用场景：功能独立、需要快速启动的页面
- 进入不独立分包页面需加载主包

### 预加载机制

- 原理：预测用户行为，提前加载可能需要的资源
- 实现方式：
  - Webpack：魔法注释webpackPrefetch
  - 小程序：preloadRule配置预加载规则
  - 原生：link rel="preload"预加载关键资源
- 策略：基于用户行为分析，空闲时加载非关键资源

### 分包异步化

- 概念：先占位渲染，分包加载后替换实际内容
- 实现模式：
  - React：Suspense + React.lazy
  - Vue：异步组件配置
  - 小程序：require.async跨包引用
- 优势：提升感知性能，实现渐进式渲染
- 分包异步化有点类似于骨架屏，先占位渲染，之后在其他包加载之后再渲染为对应组件

### 包大小控制

- 限制标准：主包≤2M，总分包≤20M（小程序标准）
- 优化策略：
  - 公共依赖提取
  - 重复代码检测
  - 按需引入第三方库
  - 资源压缩和优化

### 跨包通信

- 限制：默认不能直接引用其他包组件
- 解决方案：
  - 异步加载：require.async或import()
  - 事件通信：全局事件总线
  - 状态共享：全局状态管理
- 设计原则：明确接口，降低耦合度

## 组件设计原则

- 复用性：通用组件抽象
- 可维护性：清晰的接口和文档
- 性能：避免不必要的渲染
- 兼容性：多端适配
- 易用性：简洁的API设计

# JavaScript

## proxy 缺点

- 兼容性：不支持IE浏览器
- 性能：处理大量数据或频繁操作对象会比Object.defineProperty稍差
- 调试：不容易看出是哪里触发了拦截

## Arguments对象

- 包含函数调用时的所有实参
- 有length属性，但不能用数组方法

## 原型和原型链

- 每个对象都有一个原型，原型也是对象
- 原型链是链式结构，终点是null
- JavaScript实现继承的核心机制

## 事件代理

- 利用事件冒泡机制
- 子元素事件统一绑定到父元素
- 动态添加元素无需重新绑定
- 减少内存占用

# TypeScript

## 接口作用

- 定义数据结构的规范
- 规定必填、可选、只读属性
- 提供类型检查和智能提示
- 便于协作和代码维护

# 浏览器

## 浏览器存储

**Cookie**

- 容量：不超过4KB
- 生命周期：可设置过期时间，不设置则浏览器关闭清除
- 作用域：同源页面，可设置domain共享子域
- 自动发送：每次HTTP请求自动携带（可设置）

**LocalStorage**

- 容量：5MB
- 生命周期：永久存储，需手动清除
- 作用域：同源页面共享

**SessionStorage**

- 容量：5MB
- 生命周期：当前会话有效，标签页关闭即清除
- 作用域：同一标签页的同源页面共享

## 同源策略

- 是一种安全机制，用于限制不同源的资源访问
- 要求协议、域名、端口完全一致

## cookie 共享规则

- cookie的作用范围主要由domain和path决定
- 同源：页面之间共享cookie
- 跨域：默认不共享cookie
- 子域名：需要设置domain才能共享cookie

## localStroage 存大数据空间可能不够

- 通过测试数据分片存储，大致计算剩余空间

- 做回溯删除测试数据

## IndexedDB

# 性能优化

## 核心指标
- 加载性能
- 资源加载大小
- 运行性能
- 内存性能

## 优化策略

**资源层面**
- Tree Shaking、压缩代码减少打包体积
- CDN分发静态资源
- 图片转WebP

**加载策略**
- 懒加载、预加载关键资源
- 按需加载
- 骨架屏优化体验
- WebView预加载（h5）

**渲染优化**
- SSR服务端渲染
- Next.js预渲染
- 虚拟列表
- 减少重排重绘

**缓存策略**
- HTTP接口缓存（响应头Cache-Control）
- 本地缓存常用数据

# 网络通讯

## SSE 断连

- SSE `onerror`事件，断链自动触发
- 设置重试间隔和最大次数
- sse没有重连机制，断开只能新建立一个连接

## WS 断连

- 心跳机制检测连接状态
- 断脸触发会`onclose`事件
- 超时认为连接断开
- 连接错误会触发`onerror`事件

## WS vs SSE

- 通信方向
  WebSocket：全双工通信，客户端和服务器可以互相发送消息
  Server-Sent Events：单向通信，只能服务器向客户端推送数据
- 协议基础
  WebSocket：独立的 WebSocket 协议，需要协议升级
  Server-Sent Events：基于 HTTP 协议，使用标准 HTTP 请求
- 数据格式
  WebSocket：支持二进制数据和文本数据
  Server-Sent Events：只支持文本数据，格式为 text/event-stream
- 连接管理
  WebSocket：持久连接，需要手动处理重连
  Server-Sent Events：浏览器自动处理重连，支持断线重连
- 适用场景
  WebSocket：聊天应用、实时游戏、协同编辑等双向通信场景
  Server-Sent Events：新闻推送、股票行情、实时通知等单向信息流场景
- CORS 限制
  WebSocket：不受同源策略限制
  Server-Sent Events：受同源策略限制，跨域需要配置 CORS
- 头部开销
  WebSocket：建立连接后头部开销很小，对服务器开销大
  Server-Sent Events：每个消息都包含 HTTP 头部信息

## 跨域解决方案

- CORS：后端配置 Access-Control-Allow-Origin
- JSONP：利用script标签，仅GET请求
- 代理服务器：开发环境中使用
- PostMessage：跨源窗口通信
- Document.domain：主域名相同时使用

## 判断网络情况

- navigator.connection：
  downlink 表示当前下载速度
  rtt 往返时延，反应网络响应速度
  effectiveType：网络类型2G、3G、4G、5G
- online、offline：
  只能判断是否有网，不能确定网络质量
- ws、sse 通过心跳检测判断
- 接口响应时间

## document.domain

- 作用：绕过浏览器同源策略限制
- 原理：手动设置document.domain = 主域名，让不同子域名页面共享同一域名
- 场景：主域名相同，子域名不同的情况下使用

# 算法

## 动态规划

1.   首先需要确保无后效性
2.   确定状态转移方程
3.   不同规模的相同问题之间的关系
4.   找到特殊值或设定特殊值

核心在于将规划问题通过递归的方式拆解

#### 优化方式

降维打击：通过滚动数组将时间复杂度降低一维

## 二叉树

算法核心在于递归

- 前序遍历：根左右，适合复制一棵树或者打印树结构
- 中序遍历：左根右，可以通过二叉搜索树排序或者寻找中间值
- 后序遍历：右根左，适合子节点依赖父节点情况

```javascript
// 前序遍历
function preorderTraversal(root) {
  const result = [];
  function traverse(node) {
    if (!node) return;
    result.push(node.val);
    traverse(node.left);
    traverse(node.right);
  }
  traverse(root);
  return result;
}

// 中序遍历
function inorderTraversal(root) {
  const result = [];
  function traverse(node) {
    if (!node) return;
    traverse(node.left);
    result.push(node.val);
    traverse(node.right);
  }
  traverse(root);
  return result;
}

// 后序遍历
function postorderTraversal(root) {
  const result = [];
  function traverse(node) {
    if (!node) return;
    traverse(node.left);
    traverse(node.right);
    result.push(node.val);
  }
  traverse(root);
  return result;
}
```

## 千分位格式化

```javascript
// 方法1: 正则
function formatNumber(num) {
  return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ',');
}

// 方法2: toLocaleString
function formatNumber(num) {
  return num.toLocaleString();
}

// 方法3: 循环
function formatNumber(num) {
  let str = num.toString();
  let result = '';
  for (let i = str.length - 1, j = 0; i >= 0; i--, j++) {
    if (j % 3 === 0 && j !== 0) result = ',' + result;
    result = str[i] + result;
  }
  return result;
}

// 方法4: 逆向累加
function formatNumber(num) {
  return num.toString().split('').reverse().reduce((acc, digit, i) => (i % 3 ? digit : digit + ',') + acc);
}
```

## 滑动窗口

通过两个指针前后进行动态滑过窗口

# 网络安全

## sameSite

`Cookie的一个属性`，主要用来防止跨站请求伪造攻击（iframe、恶意链接、自动表单），有三个值

1. Strict严格：只有当前页面的网页发起请求Cookie才会被发送
2. Lax宽松：允许再安全的跨站请求中携带Cookie
3. None不限制：任何请求都携带Cookie，需同时设置Secure

## token 防止被窃取

- 使用httpOnly存token，避免js读取
- 设置较短的时间，使得风险可控
- 重要操作前二次验证

## JWT

- JWT是token的一种具体实现方式
- JWT的特点是把用户信息铭文base64存放在令牌里，服务器不用查就能验证身份
- JWT：header头 + payload用户信息 + signture头和用户信息连一起用密钥加密

# AI

## AI 大语言模型LLM (Large Language Model)

![image-20251125231031837](面试指南.assets/image-20251125231031837.png)

### 大语言模型原理

1. 提示词被tokenizer切分成token

   token是大模型最小理解单元，每个token都对应一个tokenID

2. Transformer《自注意力机制》捕捉上下文关联
   通过递归最新的token集合，每次一个token的逐渐计算（本质就是不断的“续写”token串）

3. RAG检索增强生成
   实现外挂知识库或者联网搜索的功能（本质是将知识库或网络上关联的内容加入到token串再计算）

### 模型类型

- 稠密模型Dense Model：每次都是全量计算（ChatGPT）

- 稀疏模型Sparse Model：降低计算量提升速度

  混合专家模型MOE（deepseek、Grok）
  通过门控网络为问题分配专家再生成结果

### 训练流程

1. 预训练pre-trainging：
   - 海量数据获得基座模型
2. 反向传播：
   - 错误回答和目标对比计算损失，更改参数，直到逼近目标（目前主要是自监督学习）
3. 后训练post trainging：
   - 给AI带标注的数据集（真人编写，也就是数据标注员），让AI模仿标注数据的风格生成内容
   - 强化学习：有点像人类的错题本，通过奖励模型不断的再训练（就是基于人工反馈的强化学习）

### Agent智能体

`LLM + mcp server`

使AI获得操作的能力，agent其实是代理的意思，通过mcp协议，去调用一系列工具，来让AI获得做事的能力

## MCP（Model Context Protocol）

`模型上下文协议`：AI模型和外部数据、工具之间的标转化桥梁

MCP是数据的转换器，有了转接器既便于AI对接不同类型的数据，又便于AI使用各种工具执行某些任务的

### MCP 协议内容

1. stdio 进程之间本地通信方式
2. JSON—RPC通信格式规范

## RAG 检索增强生成

AI回答是先从外部知识库（公司文档、产品手册）里检索相关信息，再结合这些信息生成答案，使得回答更贴合具体场景

## AI看法

**原理**：

把prompt拆成token，根据现有token一步一个token的向外推理

**缺陷**

- 本质（概率），生成的越多，错误的概率越高
- AI不一定正确

**更好的使用AI**

- 顶层设计 ➕ 任务拆分
- 知识的深度，判断AI内容正确性
- 效率 + 摆脱很多枯燥简单的事情，专注于顶层设计


# 黑话

## 数据监控

**PV**：页面浏览量，页面加载完成即统计（页面加载完成后就发请求，window.onload）
**UV**：独立访客数，通过Cookie UUID去重（UUID存到cookie里，之后每次访问都带着标识请求后端，后端做去重）

# 手写题

## 柯里化
```javascript
function curry(fn) {
  return function curried(...args) {
    if (args.length >= fn.length) {
      return fn.apply(this, args);
    } else {
      return function(...args2) {
        return curried.apply(this, args.concat(args2));
      }
    }
  };
}
```

## 数组扁平化

```javascript
// 方法1: flat
function flatten(arr) {
  return arr.flat(Infinity);
}

// 方法2: reduce递归
function flatten(arr) {
  return arr.reduce((a, b) => a.concat(Array.isArray(b) ? flatten(b) : b), []);
}

// 方法3: toString + map
function flatten(arr) {
  return arr.toString().split(',').map(Number);
}

// 方法4: while + concat
function flatten(arr) {
  while (arr.some(Array.isArray)) {
    arr = [].concat(...arr);
  }
  return arr;
}
```

## 发布订阅

```javascript
class PubSub {
  constructor() {
    this.events = {
      'API:UN_AUTH': new Set(),
    };
  }

  subscribe(eventName, callback) {
    this.events[eventName].add(callback);
  }
  
  publish(eventName, ...args) {
    this.events[eventName].forEach(callback => {
      callback(...args);
    });
  }
  
  unsubscribe(event, callback) {
    this.events[event].delete(callback);
  }
}
```

## 防抖节流

### 优化

- 考虑边界情况，添加取消功能
- 考虑组件卸载时清除未执行定时器，避免内存泄漏
- 性能和体验平衡：操作超过300ms强制执行一次回掉，避免用户觉得延迟

```javascript
// 防抖
function debounce(fn, delay) {
  let timer;
  return function() {
    clearTimeout(timer);
    timer = setTimeout(() => fn.apply(this, arguments), delay);
  };
}

// 节流
function throttle(fn, delay) {
  let timer;
  return function() {
    if (!timer) {
      timer = setTimeout(() => {
        fn.apply(this, arguments);
        timer = null;
      }, delay);
    }
  };
}
```



## PostMessage异步封装

```javascript
function postMessageAsync(data, targetOrigin = '*', timeout = 5000) {
  return new Promise((resolve, reject) => {
    const timer = setTimeout(() => reject('timeout'), timeout);
    
    const handler = (event) => {
      if (event.source !== window) return;
      clearTimeout(timer);
      window.removeEventListener('message', handler);
      resolve(event.data);
    };
    
    window.addEventListener('message', handler);
    window.postMessage(data, targetOrigin);
  });
}

// 使用
postMessageAsync('hello')
  .then(response => console.log(response))
  .catch(error => console.error(error));
```

## 异步队列

```javascript
class AsyncQueue {
  constructor() {
    this.tasks = [];
    this.running = false;
  }

  add(task) {
    this.tasks.push(task);
    if (!this.running) this.run();
  }

  async run() {
    this.running = true;
    while (this.tasks.length > 0) {
      const task = this.tasks.shift();
      await task();
    }
    this.running = false;
  }
}
```


# 场景题

## 地图性能优化

- 减少同时渲染的POI数量
- 相近标记合并，放大后展开
- 瓦片预加载和缓存
- 按优先级排序加载
- 防抖节流减少重排重绘

# 面试技巧

## STAR原则

- Situation情景 —— 面临问题的背景

- Target目标 —— 需要实现的目标`关键：为什么要做这件事情，背后的价值`

- Action行动 —— 做了什么内容`强调难点，自身做的突出的部分`

- Result结果 —— 取得什么效果`体现最终结果带来的价值`

- 举例：S运维同事大量时间浪费在宣发海报上，T AI + 脚本批量生产（解放人力），A 通过Node写了一个微服务，调研选择通过无头浏览器 ➕ Django模版的方式输出图片，和 AI 后端的同事协调，最终跑出完整的流程， R 产品只需要验收

## OKR管理

- Objectives：目标
- Key Result：关键结果
- 周期不低于3个月，关键结果不超过5个
- 低于0.3：目标太高 or 人员能力不足
- 满分：目标太低，自我设限太多
- OKR的关键在于职员知道领导在想什么，让领导知道职员进度
- 透明公开，鼓励沟通，随时跟进
- 目标要精准，不要把任务当作结果，最终是一种结果的目标导向

## 问题解决思路

1. 分析问题，找到开端
2. 执行，选择方案（demo）
3. 请求资源，办成这件事

## 技术深度展示

**项目难点突破**

- 识别技术瓶颈和性能问题
- 调研多种解决方案和权衡
- 实施优化并验证效果
- 总结经验和最佳实践

**架构设计能力**

- 系统模块划分和职责分离
- 接口设计和数据流管理
- 扩展性和维护性考虑
- 性能和安全保障措施

## 沟通表达能力

**技术方案阐述**

- 先总后分的逻辑结构
- 关键技术和创新点突出
- 数据支撑和效果验证
- 遇到的挑战和解决方案

**团队协作体现**

- 跨部门协调沟通经验
- 技术分享和知识传递
- 代码规范和质量保障
- 项目管理和进度控制

# 英文工作能力

## 自我介绍

Hello, my name is Jove. I'm a software development engineer. I'm very glad to interview here and I'm looking forward to working with everyone. Thank you!


# HR

## 职业规划

**短期**：熟悉技术栈和流程
**中期**：成长为技术骨干，关注前沿技术
**长期**：带领团队攻坚核心项目，技术为业务赋能

## 个人展现

不满足现状 + 主动思考 + 注定行动 + 解决痛点（结果和落地能力）

1. 不光提升个人，还能提升团队！（举例）
2. 透露出我想要变强

## 协作时遇到的沟通方面的困难，如何解决双方的不一致与冲突

很多时候大家的讨论是比较发散的，从问题本身延伸到需求设计等等
这里我比较推崇影视飓风的开会理念，规定好会议需要达成哪些共识，需要哪些人协作，大家有哪些问题或者困难都先提前写好。在对这一切每个人都梳理过后，大家开会快速的对其，避免无意义的发散。目标感不是很明确，开会就会变得冗长效果差。

## 上级为你布置了你完全不感兴趣或者不想做的任务的情况你该如何处理

首先工作中，感不感兴趣不是首要标准，有没有价值才是
另外不想做的原因是什么？个人理解是无效工作？还是重复性劳动。首先如何个人觉得方向错误，那就应该及时和领导沟通，阐述自己的思考与担忧，把任务了解清楚，是不是有一些误解。如果是重复性劳动，作为一面开发这，如何通过脚本，快速或者提效的方式去解决

## 综合看你的能力还达不到要求

这几天也复盘了前几轮面试自己答的还不够的一些问题，自己也整理出来做了一些复习，今后的学习和工作也会更加强这方面的补充，当然也希望您能指点一下，相信未来我们还有合作的机会。（不要展现出可惜与悲伤）

# 待学习

- [x] mcp server
- [x] 抓包

wireshark

- [x] 分包

- [ ] 避免小程序重复发版 excl 脚本注入、文件注入
- [ ] TP99、TP999
- [ ] 测试用例管理
- [ ] 自动化测试
- [ ] 如何灰度
  路由控制：在路由拦截判断是否在灰度名单，跳转不同的页面
  动态加载组件：灰度用户加载新组件，其他用户加载旧组件
  cookie：通过标识在逻辑层判断
- [ ] 防止白屏
  1. try catch
  2. 做好监控
  3. 版本管理三部曲：可灰度、可监控、可回滚
- [ ] 浏览器调试真机（代理）
- [ ] usecallback
- [ ] entree
- [ ] whistle
- [ ] h5和canvas区别
- [ ] 流媒体压缩优化
- [ ] 埋点
- [ ] 数据容灾
- [ ] 错误上报
- [ ] 如何部署history模式
  将所有请求都转发到index.html
- [ ] usememo
- [ ] usb调试
- [ ] 协商缓存与强缓存
- [ ] 包下载
- [ ] 小程序性能指标
- [ ] whistle
- [ ] IndexedDB
- [ ] AST
