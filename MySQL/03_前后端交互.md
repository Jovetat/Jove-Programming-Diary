# 前后端交互

## web 开发模式

#### 基于服务端渲染的传统 web 开发模式

服务端渲染：服务器发送给客户端的 HTML 页面是在服务器通过字符串拼接动态生成的，因此客户端不需要使用 Ajax 这样的技术额外请求页面的数据

>   优点
>
>   前端耗时少
>
>   有利于SEO，因为服务器响应的是完整的 HTML 页面内容，所以利于爬虫爬取信息

>   缺点
>
>   占用服务器端资源，服务器端完成 HTML 页面内容的拼接，请求较多会对服务器造成一定压力
>
>   不利于前后端分离，开发效率低

#### 基于前后端分离的新型 web 开发模式

前后端分离的概念：前后端分离依赖于 Ajax 技术的广泛应用，后端只负责提供 API 接口，前端使用 Ajax 调用接口

>   优点
>
>   开发体验好，前端专注于 UI 页面的开发，后端专注于 api 的开发
>
>   用户体验好，Ajax 轻松实现页面的局部刷新
>
>   减轻了服务器端的渲染压力，页面最终是在每个用户的浏览器中生成的

>   缺点
>
>   不利于 SEO，完整的 HTML 页面需要在客户端动态拼接完成，所以爬虫无法爬取页面的有效信息
>
>   （解决方案：利用 Vue、React等前端框架的 SSR(server side render) 技术可以解决 SEO 问题）

#### 如何选择 web 开发模式

企业级网站：主要功能是展示而没有复杂的交互，并且需要良好的 SEO，选择服务器端渲染

后台管理：交互性较强，不需要考虑 SEO，选择前后端分离的开发模式

为了同时兼顾首页的渲染速度和前后端分离的开发效率，采用首屏服务器渲染 + 其他页面前后端分离的开发模式

## 身份认证

` 身份认证（Authentication）[身份验证、鉴权]：通过一定手段完成对用户身份的确认`

对于服务器渲染和前后端分离这两种开发模式分别有着不同的身份认证方案

### 服务端渲染推荐使用 Session 认证机制

#### HTTP 协议的无状态性

` 客户端每次的 HTTP 请求都是独立的，连续多个请求之间没有直接的关系，服务器不会主动保留每次 HTTP 请求的状态`

#### 突破 HTTP 无状态的限制 —— Cookie

` Cookie 是存储在用户浏览器中的一段不超过 4kb 的字符串，由一个键值对name、value和其他几个用于控制 Cookie 有效期、安全性、适用范围的可选属性组成`

不同域名下的 Cookie 各自独立，每当客户端发起请求时，会自动把当前域名下所有未过期的 Cookie 一同发送给服务器

>   Cookie 的特性：
>
>   自动发送
>
>   域名独立
>
>   过期时限
>
>   4kb 限制

#### Cookie 在身份认证中的作用

客户端第一次请求服务器的时候，服务器通过响应头的形式，向客户端发送一个身份认证的 Cookie，客户端会自动将 Cookie 保存在浏览器中

当客户端浏览器每次请求服务器的时候，浏览器会自动将身份认证相关的 Cookie，通过请求头的形式发送给服务器，服务器即可验明客户端的身份

![image-20230325163709248](03_前后端交互.assets/image-20230325163709248.png)

#### Session 认证机制

##### Cookie 不具有安全性

` 由于 Cookie 是存储在浏览器中的，而且浏览器也提供了读写 Cookie 的 API，因此 Cookie 很容易被伪造，不具有安全性，因此不建议服务器将重要的隐私数据通过 Cookie 的形式发送给浏览器`

所以不要使用 Cookie 存储用户的身份信息、密码等重要的隐私数据

##### Session 的工作原理

![image-20230325171910495](03_前后端交互.assets/image-20230325171910495.png)

### 在 Express 中使用 Session 认证

` 安装 express-session 中间件`

``` 
npm install express-session
```

` 配置 express-session 中间件`

``` js
const session = require('express-session')
// 配置 session
app.use(session({
    secret: 'keyboard cat', // secret属性可以为任意字符串
    resave: false, // 固定写法
    saveUninitialized: true // 固定写法
}))
```

#### 向 session 中存数据

` 配置成功后即可通过 req.session 来访问和使用 session 对象，从而存储用户的关键信息`

``` js
app.post('/api/login',(req, res)=>{
    if(req.body.username !== 'admin' || req.body.password !== '123456')
        return res.send({ status: 1, msg: '登陆失败'})
    // 判断登录信息正确即可将用户信息和登陆状态存储到 session 中
    req.session.user = req.body
    req.session.islogin = true
    res.send({ status: 0, meg: '登陆成功'})
})
```

#### 从 session 中取数据

` 从 req.session 对象上获取存储的数据`

``` js
// 其他接口获取数据
app.get('/api/username', (req, res)=>{
    // 判断用户是否登录
    if(!req.session.islogin){
        return res.send({ status: 1, msg: 'fail'})
    }
    res.sned({ status: 0, msg: 'success', username: req.session.user.username })
})
```

#### 清空session

` req,session.destroy() 清空服务器保存的 session 信息`

``` js
// 退出登录的接口
app.post('/api/logput', (req, res)=>{
    // 清空当前客户端对应的 session 信息
    req.session.destroy()
    res.send({ status: 0, msg: '退出登录成功' })
})
```

只会清空当前用户对应的 session，不会清空服务器中所有的 session

### 前后端分离推荐使用 JWT 认证机制